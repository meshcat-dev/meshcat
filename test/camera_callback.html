<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>MeshCat</title>
	</head>
	<body>
        <div id="test-message">
          Open the console in developer tools (F12).
          <br><br>
          Click the button below to turn on/off camera tracking.
          <br><br>
          When camera tracking is enabled, some diagnostics will be written to
          the console. Specifically, the distance the camera is to its target,
          the deviation between the direction to the target and the reported
          camera viewing direction.

          Generally, you'll note that the distance between camera and target is
          largely constant (during rotation operations). The reported camera
          position is quite reliable.

          In principle, the cameras basis should be defined such that the
          camera's viewing direction should point toward the target point. In
          practice, this isn't true. We report the angular deviation between
          the camera's reported basis and the direction toward the target.
          Ideally, that deviation would be zero. Deviation is most likely with
          <i>rapid</i> mouse motion. Slow motion (and particularly a stationary
          moment before releasing the mouse button) will increase the odds that
          the reported camera matrix is properly aligned.
          <br><br>
          <div id="camera-pose">[If you read this, the page is broken]</div>
        </div>

        <div id="meshcat-pane">

        </div><button id="camera-button">[If you read this, the page is broken]</button>

        <script src="main.min.js"></script>
        <script>
            function make_cube(size, color, position) {
                let geo = new MeshCat.THREE.BoxGeometry(size, size, size);
                let mat = new MeshCat.THREE.MeshLambertMaterial({ color: color });
                let mesh = new MeshCat.THREE.Mesh(geo, mat);
                mesh.position.fromArray(position);
                return mesh;
            }

            var viewer = new MeshCat.Viewer(document.getElementById("meshcat-pane"));
            try {
                viewer.connect();
            } catch (e) {
                console.info("Not connected to MeshCat websocket server: ", e);
            }
            viewer.scene.add(make_cube(1, 0x00ff00, [0, 0, 0]));

            // Callback state:
            //   0: No callback.
            //   1: Callback on interaction end.
            //   2: Callback on all changes.
            var callback_state = 0;
            // We'll execute the API directly here.
            viewer.set_camera_pose_callback(null);

            var button_messages = [
                "Click to enable camera callback on interaction end",
                "Click to enable camera callback on all changes",
                "Click to disable camera callback",
            ];
            var feedback_messages = [
                "No callback registered",
                "Callback prints pose to console at the end of an interaction" +
                " (mouse up or mouse wheel)",
                "Callback prints pose for all changes; " +
                "rapid mouse movement will produce large angular deviations"
            ];
            var button = document.getElementById("camera-button");
            var pose_div = document.getElementById("camera-pose");
            pose_div.innerText = feedback_messages[callback_state];
            button.innerText = button_messages[callback_state];

            var toggle_display = () => {
                // Execute the API via the command here.
                callback_state = (callback_state + 1) % 3;
                viewer.handle_command({
                    type: "set_camera_pose_callback",
                    callback: callback_state == 0 ?
                        null :
                        `(viewer) => {
                            let X_WC = viewer.camera.matrixWorld.elements;
                            let p_TC_W = viewer.controls.target.clone();
                            let p_WC = {x: X_WC[12], y: X_WC[13], z: X_WC[14]};
                            p_TC_W.sub(p_WC);
                            let dist = p_TC_W.length();
                            p_TC_W.divideScalar(dist);
                            let neg_camz_W = {x: -X_WC[8], y: -X_WC[9], z: -X_WC[10]};
                            // The camera should look in the direction of the
                            // target; the angular deviation between -Cz_W and p_TC
                            // should be zero. The deviation grows for fast mouse
                            // movement.
                            let dp = Math.min(p_TC_W.dot(neg_camz_W), 1);
                            let deviation = Math.acos(dp) * 180 / Math.PI;
                            console.info('A deviation of ' +
                                         deviation.toString() +
                                         ' degrees at '
                                         + dist.toString() + ' m distance');
                        }`,
                    on_end_only: callback_state == 1
                });
                pose_div.innerText = feedback_messages[callback_state];
                button.innerText = button_messages[callback_state];
            };
            button.addEventListener("click", toggle_display);
        </script>


         <style>
            body {
                margin: 0;
            }

            #meshcat-pane {
                width: 100vw;
                height: 100vh;
                overflow: hidden;
            }

            #test-message{
                width: 90vw;
                text-align: left;
                background-color: rgb(232, 232, 232);
                position: fixed;
                left: 0%;
                display: block;
                padding: 10px;
            }
            #camera-button {
                width: 90vw;
                position: fixed;
                left: 5vw;
                bottom: 10px;
            }
        </style>
        <script id="embedded-json"></script>
	</body>
</html>
